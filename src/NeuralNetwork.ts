import { Agent } from "./Agent";

type Point = { x: number; y: number };

class NeuralNetwork {
  levels: Level[];

  /**
   * Creates a new neural network with the specified number of neurons in each layer.
   *
   * @param layerSizes An array where each element represents the number of neurons in that layer.
   *                   Example: [3, 4, 2] means:
   *                   - 3 neurons in the input layer,
   *                   - 4 neurons in the hidden layer,
   *                   - 2 neurons in the output layer.
   */
  constructor(layerSizes: number[]) {
    this.levels = [];
    for (let i = 0; i < layerSizes.length - 1; i++) {
      this.levels.push(new Level(layerSizes[i], layerSizes[i + 1]));
    }
  }

  /**
   * Feed the input data through the neural network and get the output.
   *
   * @param inputs The input values to feed into the network.
   * @param network The neural network object to be used.
   * @returns The output values generated by the network.
   */
  public feedForward(inputs: number[]): number[] {
    let outputs = Level.feedForward(inputs, this.levels[0]);
    for (let i = 1; i < this.levels.length; i++) {
      outputs = Level.feedForward(outputs, this.levels[i]);
    }
    return outputs;
  }

  /**
   * Apply random mutations to the network's weights and biases.
   * This is often used in genetic algorithms or for introducing randomness in training.
   *
   * @param network The neural network to mutate.
   * @param mutationRate The rate at which to apply the mutations. Default is 1.
   */
  public mutate(mutationRate = 1): void {
    this.levels.forEach((level) => {
      for (let i = 0; i < level.biases.length; i++) {
        level.biases[i] = lerp(
          level.biases[i],
          Math.random() * 2 - 1,
          mutationRate
        );
      }
      for (let i = 0; i < level.weights.length; i++) {
        for (let j = 0; j < level.weights[i].length; j++) {
          level.weights[i][j] = lerp(
            level.weights[i][j],
            Math.random() * 2 - 1,
            mutationRate
          );
        }
      }
    });
  }
}

class Sensor {
  public agent: Agent;
  public rayCount: number;
  public rayLength: number;
  public raySpread: number;

  public rays: { x: number; y: number }[][];
  public output: any[];

  constructor(agent: Agent, config: { RayCount: number; RayLength: number }) {
    this.agent = agent;
    this.rayCount = config.RayCount;
    this.rayLength = config.RayLength;
    this.raySpread = Math.PI / 2;
    this.rays = [];
    this.output = [];
  }

  public update(entities: any[]): void {
    this.castRays();
    this.output = [];

    for (let i = 0; i < this.rays.length; i++) {
      this.output.push(this.getOutput(this.rays[i], entities));
    }
  }
  private getOutput(ray: Point[], entities: any): any {
    let intersections = [];

    function getIntersection(A: Point, B: Point, C: Point, D: Point) {
      const tTop = (D.x - C.x) * (A.y - C.y) - (D.y - C.y) * (A.x - C.x);
      const uTop = (C.y - A.y) * (A.x - B.x) - (C.x - A.x) * (A.y - B.y);
      const bottom = (D.y - C.y) * (B.x - A.x) - (D.x - C.x) * (B.y - A.y);

      if (bottom != 0) {
        const t = tTop / bottom;
        const u = uTop / bottom;
        if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
          return {
            x: lerp(A.x, B.x, t),
            y: lerp(A.y, B.y, t),
            offset: t,
          };
        }
      }

      return null;
    }

    for (let entity of entities) {
      if (entity === this.agent) {
        continue;
      }
      let polygon = entity.polygon;
      for (let i = 0; i < polygon.length; i++) {
        const intersection = getIntersection(
          ray[0],
          ray[1],
          polygon[i],
          polygon[(i + 1) % polygon.length]
        );
        if (intersection) {
          intersections.push(intersection);
        }
      }
    }

    if (intersections.length == 0) {
      return null;
    } else {
      const offsets = intersections.map((e) => e.offset);
      const minOffset = Math.min(...offsets);
      return intersections.find((e) => e.offset == minOffset);
    }
  }

  private castRays(): void {
    this.rays = [];

    for (let i = 0; i < this.rayCount; i++) {
      const angle =
        lerp(
          this.raySpread / 2,
          -this.raySpread / 2,
          this.rayCount == 1 ? 0.5 : i / (this.rayCount - 1)
        ) + this.agent.position.rotation;

      const start = { x: this.agent.position.x, y: this.agent.position.y };
      const end = {
        x: this.agent.position.x - Math.sin(angle) * this.rayLength,
        y: this.agent.position.y - Math.cos(angle) * this.rayLength,
      };
      this.rays.push([start, end]);
    }
  }

  public render(ctx: CanvasRenderingContext2D): void {
    for (let i = 0; i < this.rayCount; i++) {
      let end = this.rays[i][1];
      if (this.output[i]) {
        end = this.output[i];
      }

      ctx.beginPath();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "yellow";
      ctx.moveTo(this.rays[i][0].x, this.rays[i][0].y);
      ctx.lineTo(end.x, end.y);
      ctx.stroke();

      ctx.beginPath();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "black";
      ctx.moveTo(this.rays[i][1].x, this.rays[i][1].y);
      ctx.lineTo(end.x, end.y);
      ctx.stroke();
    }
  }
}

class Level {
  inputs: number[];
  outputs: number[];
  biases: number[];
  weights: number[][];

  /**
   * Creates a new layer in the neural network.
   *
   * @param inputCount The number of input neurons feeding into this layer.
   * @param outputCount The number of neurons in this layer (the output neurons).
   */
  constructor(inputCount: number, outputCount: number) {
    this.inputs = new Array(inputCount);
    this.outputs = new Array(outputCount);
    this.biases = new Array(outputCount);
    this.weights = [];
    for (let i = 0; i < inputCount; i++) {
      this.weights[i] = new Array(outputCount);
    }
    Level.randomize(this);
  }

  // Randomly initialize the weights and biases
  private static randomize(level: Level): void {
    for (let i = 0; i < level.inputs.length; i++) {
      for (let j = 0; j < level.outputs.length; j++) {
        level.weights[i][j] = Math.random() * 2 - 1; // Random weights between -1 and 1
      }
    }
    for (let i = 0; i < level.biases.length; i++) {
      level.biases[i] = Math.random() * 2 - 1; // Random biases between -1 and 1
    }
  }

  /**
   * Perform the feedforward operation for this layer and return the output.
   *
   * @param givenInputs The inputs to be processed by this layer.
   * @param level The current layer object being processed.
   * @returns The output values after processing the inputs through the layer.
   */
  static feedForward(givenInputs: number[], level: Level): number[] {
    // Copy the input values into the inputs array of the layer
    for (let i = 0; i < level.inputs.length; i++) {
      level.inputs[i] = givenInputs[i];
    }

    // Calculate the outputs for the layer
    for (let i = 0; i < level.outputs.length; i++) {
      let sum = 0;
      for (let j = 0; j < level.inputs.length; j++) {
        sum += level.inputs[j] * level.weights[j][i];
      }

      // Add the bias and apply the tanh activation function
      sum += level.biases[i];
      level.outputs[i] = Math.tanh(sum); // Apply tanh activation
    }

    return level.outputs;
  }
}

// Linear interpolation function used in mutation to blend two values
function lerp(start: number, end: number, amount: number): number {
  return start + (end - start) * amount;
}

export { NeuralNetwork, Sensor };

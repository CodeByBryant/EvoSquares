/**
 * @author By Bryant Ejorh - CodeByBryant
 *
 * License: MIT License 2024
 *
 * @fileoverview This file contains the implementation of a neural network and a sensor system for an agent.
 */

import { Agent } from "./Agent";
import { Point } from "../utilities/utilities.ts";

/**
 * Class representing a neural network.
 * The neural network consists of multiple layers (levels) with weights and biases.
 * It allows for feed-forward operations and mutation of weights and biases.
 */
class NeuralNetwork {
  levels: Level[];

  /**
   * Creates a new neural network with the specified number of neurons in each layer.
   * @param layerSizes An array where each element represents the number of neurons in that layer.
   *                   Example: [3, 4, 2] means:
   *                   - 3 neurons in the input layer,
   *                   - 4 neurons in the hidden layer,
   *                   - 2 neurons in the output layer.
   */
  constructor(layerSizes: number[]) {
    this.levels = [];

    // Create levels based on the number of neurons specified in the layerSizes array
    for (let i = 0; i < layerSizes.length - 1; i++) {
      this.levels.push(new Level(layerSizes[i], layerSizes[i + 1]));
    }
  }

  /**
   * Feeds the input data through the neural network and gets the output.
   * @param inputs The input values to feed into the network.
   * @returns The output values generated by the network after processing through all layers.
   */
  public feedForward(inputs: number[]): number[] {
    let outputs = Level.feedForward(inputs, this.levels[0]);

    // Feed the outputs through each subsequent layer
    for (let i = 1; i < this.levels.length; i++) {
      outputs = Level.feedForward(outputs, this.levels[i]);
    }
    return outputs;
  }

  /**
   * Apply random mutations to the network's weights and biases.
   * This is often used in genetic algorithms or for introducing randomness in training.
   * @param mutationRate The rate at which to apply the mutations (default is 1).
   */
  public mutate(mutationRate = 1): void {
    this.levels.forEach((level) => {
      // Mutate the biases and weights by a certain amount based on mutationRate
      for (let i = 0; i < level.biases.length; i++) {
        level.biases[i] = lerp(
          level.biases[i],
          Math.random() * 2 - 1,
          mutationRate
        );
      }
      for (let i = 0; i < level.weights.length; i++) {
        for (let j = 0; j < level.weights[i].length; j++) {
          level.weights[i][j] = lerp(
            level.weights[i][j],
            Math.random() * 2 - 1,
            mutationRate
          );
        }
      }
    });
  }
}

/**
 * Class representing a sensor for an agent, which uses ray-casting to detect obstacles and entities.
 * The sensor casts rays in multiple directions and returns the closest intersection with an entity.
 */
class Sensor {
  public agent: Agent;
  public rayCount: number;
  public rayLength: number;
  public raySpread: number;

  public rays: { x: number; y: number }[][];
  public output: any[];

  /**
   * Creates a new sensor for the specified agent.
   * @param agent The agent that owns the sensor.
   * @param config Configuration object specifying the number of rays and their length.
   */
  constructor(agent: Agent, config: { RayCount: number; RayLength: number }) {
    this.agent = agent;
    this.rayCount = config.RayCount;
    this.rayLength = config.RayLength;
    this.raySpread = Math.PI / 2; // Default spread of rays is 90 degrees
    this.rays = [];
    this.output = [];
  }

  /**
   * Updates the sensor by casting rays and calculating the output for each ray.
   * @param entities A list of entities in the environment to check for intersections.
   */
  public update(entities: any[]): void {
    this.castRays();
    this.output = [];

    // For each ray, determine its output (intersection point with any entity)
    for (let i = 0; i < this.rays.length; i++) {
      this.output.push(this.getOutput(this.rays[i], entities));
    }
  }

  /**
   * Calculates the closest intersection of a ray with any entities.
   * @param ray A ray represented by two points (start and end).
   * @param entities A list of entities to check for intersections.
   * @returns The intersection point if any is found, otherwise null.
   */
  private getOutput(ray: Point[], entities: any): any {
    let intersections = [];

    // Helper function to calculate the intersection between two line segments
    function getIntersection(A: Point, B: Point, C: Point, D: Point) {
      const tTop = (D.x - C.x) * (A.y - C.y) - (D.y - C.y) * (A.x - C.x);
      const uTop = (C.y - A.y) * (A.x - B.x) - (C.x - A.x) * (A.y - B.y);
      const bottom = (D.y - C.y) * (B.x - A.x) - (D.x - C.x) * (B.y - A.y);

      if (bottom != 0) {
        const t = tTop / bottom;
        const u = uTop / bottom;
        if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
          return {
            x: lerp(A.x, B.x, t),
            y: lerp(A.y, B.y, t),
            offset: t,
          };
        }
      }
      return null;
    }

    // Check for intersections with each entity's polygon
    for (let entity of entities) {
      if (entity === this.agent) {
        continue;
      }
      let polygon = entity.polygon;
      for (let i = 0; i < polygon.length; i++) {
        const intersection = getIntersection(
          ray[0],
          ray[1],
          polygon[i],
          polygon[(i + 1) % polygon.length]
        );
        if (intersection) {
          intersections.push(intersection);
        }
      }
    }

    // Return the closest intersection or null if no intersections are found
    if (intersections.length == 0) {
      return null;
    } else {
      const offsets = intersections.map((e) => e.offset);
      const minOffset = Math.min(...offsets);
      return intersections.find((e) => e.offset == minOffset);
    }
  }

  /**
   * Casts multiple rays from the agent in different directions based on rayCount and raySpread.
   */
  private castRays(): void {
    this.rays = [];

    // For each ray, calculate its angle and the end point
    for (let i = 0; i < this.rayCount; i++) {
      const angle =
        lerp(
          this.raySpread / 2,
          -this.raySpread / 2,
          this.rayCount == 1 ? 0.5 : i / (this.rayCount - 1)
        ) + this.agent.position.rotation;

      const start = { x: this.agent.position.x, y: this.agent.position.y };
      const end = {
        x: this.agent.position.x - Math.sin(angle) * this.rayLength,
        y: this.agent.position.y - Math.cos(angle) * this.rayLength,
      };
      this.rays.push([start, end]);
    }
  }

  /**
   * Renders the rays and their outputs (intersections) on the given canvas context.
   * @param ctx The CanvasRenderingContext2D to draw the rays on.
   */
  public render(ctx: CanvasRenderingContext2D): void {
    for (let i = 0; i < this.rayCount; i++) {
      let end = this.rays[i][1];
      if (this.output[i]) {
        end = this.output[i];
      }

      // Render the rays with a yellow line and a black line to show intersection
      ctx.beginPath();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "yellow";
      ctx.moveTo(this.rays[i][0].x, this.rays[i][0].y);
      ctx.lineTo(end.x, end.y);
      ctx.stroke();

      ctx.beginPath();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "black";
      ctx.moveTo(this.rays[i][1].x, this.rays[i][1].y);
      ctx.lineTo(end.x, end.y);
      ctx.stroke();
    }
  }
}

/**
 * Class representing a single layer in the neural network.
 * Each level holds its own weights, biases, inputs, and outputs.
 */
class Level {
  inputs: number[];
  outputs: number[];
  biases: number[];
  weights: number[][];

  /**
   * Creates a new layer in the neural network.
   * @param inputCount The number of input neurons feeding into this layer.
   * @param outputCount The number of neurons in this layer (the output neurons).
   */
  constructor(inputCount: number, outputCount: number) {
    this.inputs = new Array(inputCount);
    this.outputs = new Array(outputCount);
    this.biases = new Array(outputCount);
    this.weights = [];
    for (let i = 0; i < inputCount; i++) {
      this.weights[i] = new Array(outputCount);
    }
    Level.randomize(this);
  }

  // Randomly initialize the weights and biases of this layer
  private static randomize(level: Level): void {
    for (let i = 0; i < level.weights.length; i++) {
      for (let j = 0; j < level.weights[i].length; j++) {
        level.weights[i][j] = Math.random() * 2 - 1;
      }
    }
    for (let i = 0; i < level.biases.length; i++) {
      level.biases[i] = Math.random() * 2 - 1;
    }
  }

  /**
   * Feeds the inputs through the layer, calculating the outputs based on weights, biases, and inputs.
   * @param inputs The inputs to be fed through the layer.
   * @param level The level to process the inputs through.
   * @returns The outputs after processing through the layer.
   */
  public static feedForward(inputs: number[], level: Level): number[] {
    // Copy the input values into the inputs array of the layer
    for (let i = 0; i < level.inputs.length; i++) {
      level.inputs[i] = inputs[i];
    }

    // Calculate the outputs for the layer
    for (let i = 0; i < level.outputs.length; i++) {
      let sum = 0;
      for (let j = 0; j < level.inputs.length; j++) {
        sum += level.inputs[j] * level.weights[j][i];
      }

      // Add the bias and apply the tanh activation function
      sum += level.biases[i];
      level.outputs[i] = this.leakyReLU(sum); // Apply tanh activation
    }

    return level.outputs;
  }

  /**
   * Leaky ReLU activation function.
   * @param x The input value to the activation function.
   * @returns The result of applying the Leaky ReLU function to x.
   */
  private static leakyReLU(x: number): number {
    const alpha = 0.01; // Small constant for negative slope
    return x >= 0 ? x : alpha * x;
  }
}

/**
 * Linear interpolation function used for random mutation of weights and biases.
 * @param a The start value.
 * @param b The end value.
 * @param t The interpolation factor (between 0 and 1).
 * @returns The interpolated value.
 */
function lerp(a: number, b: number, t: number): number {
  return a + t * (b - a);
}

export { NeuralNetwork, Sensor };
